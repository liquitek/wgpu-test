<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Кубик</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Roboto}
  canvas{display:block;width:100%;height:100%}
  #overlay{position:absolute;left:1rem;bottom:1rem;background:#0006;padding:.6rem;border-radius:.4rem}
</style>
</head>
<body>
<canvas id="gpuCanvas"></canvas>
<div id="overlay">Click to lock pointer — WSAD to move, LShift/Z up/down, Ctrl rotate Z.
  <div id="info"></div>
</div>
<div  style="position: absolute;top:0;left:0;font-size: 1.5rem;font-weight: bold;font-family: monospace;">FPS:<output id="fps"></output></div>
<script id="geomVS" type="text/wgsl">
  struct U {
  view: mat4x4<f32>,
  proj: mat4x4<f32>,
};
@binding(0) @group(0) var<uniform> u: U;
@binding(3) @group(0) var<uniform> model: mat4x4<f32>;

struct VSout {
  @builtin(position) position : vec4<f32>,
  @location(0) worldPos : vec3<f32>,
  @location(1) normal : vec3<f32>,
  @location(2) uv : vec2<f32>
};

@vertex
fn main(@location(0) inPos: vec3<f32>,
        @location(1) inNormal: vec3<f32>,
        @location(2) inUV: vec2<f32>) -> VSout {
  var o : VSout;
  let world4 = model * vec4<f32>(inPos, 1.0);
  o.position = u.proj * u.view * world4;
  o.worldPos = world4.xyz;
  o.normal = normalize((model * vec4<f32>(inNormal,0.0)).xyz);
  o.uv = inUV;
  return o;
}
</script>

<script id="geomFS" type="text/wgsl">
@group(0) @binding(1) var texSampler : sampler;
@group(0) @binding(2) var tex : texture_2d<f32>;

struct FSout {
  @location(0) gPosition : vec4<f32>,
  @location(1) gNormal : vec4<f32>,
  @location(2) gAlbedo : vec4<f32>
};

@fragment
fn main(@location(0) worldPos : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv: vec2<f32>) -> FSout {
  var o: FSout;
  o.gPosition = vec4<f32>(worldPos, 1.0);     // world space
  o.gNormal = vec4<f32>(normalize(normal), 1.0); // world space normal
  o.gAlbedo = textureSample(tex, texSampler, uv);
  return o;
}
</script>
<script id="geomVS_PBR" type="text/wgsl">
  struct U {
  view: mat4x4<f32>,
  proj: mat4x4<f32>,
};
@binding(0) @group(0) var<uniform> u: U;
@binding(1) @group(0) var<uniform> model: mat4x4<f32>;

struct VSout {
  @builtin(position) position : vec4<f32>,
  @location(0) worldPos : vec3<f32>,
  @location(1) normal : vec3<f32>,
  @location(2) uv : vec2<f32>,
  @location(3) depth: f32
};

@vertex
fn main(@location(0) inPos: vec3<f32>,
        @location(1) inNormal: vec3<f32>,
        @location(2) inUV: vec2<f32>) -> VSout {
  var o : VSout;
  let world4 = model * vec4<f32>(inPos, 1.0);
  o.position = u.proj * u.view * world4;
  o.worldPos = world4.xyz;
  o.normal = normalize((model * vec4<f32>(inNormal,0.0)).xyz);
  o.uv = inUV;
  o.depth = o.position.z;
  return o;
}
</script>
<script id="geomFS_PBR" type="text/wgsl">
@group(1) @binding(0) var texSampler : sampler;
@group(1) @binding(1) var albedo : texture_2d<f32>;
@group(1) @binding(2) var material : texture_2d<f32>;

struct FSout {
  @location(0) gPosition : vec4<f32>,
  @location(1) gNormal : vec4<f32>,
  @location(2) gAlbedo : vec4<f32>,
  @location(3) gMaterial : vec4<f32>
};

@fragment
fn main(@location(0) worldPos : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) depth: f32 ) -> FSout {
  var o: FSout;
  o.gPosition = vec4<f32>(worldPos, 1.0);     // world space
  o.gNormal = vec4<f32>(normalize(normal), 1.0); // world space normal
  o.gAlbedo = textureSample(albedo, texSampler, uv);
  o.gAlbedo.w = depth;
  o.gMaterial = textureSample(material, texSampler, uv);
  return o;
}
</script>
<script id="lightVS" type="text/wgsl">
struct VSout {
  @builtin(position) position : vec4<f32>,
  @location(0) @interpolate(flat) li : u32
}; 
@vertex fn main(@builtin(vertex_index) vi: u32, @builtin(instance_index) li: u32) -> VSout {
  var o:VSout;
  var pos = array<vec2<f32>,3>( vec2<f32>(-1.0,-1.0), vec2<f32>(3.0,-1.0), vec2<f32>(-1.0,3.0) );
  o.position =  vec4<f32>(pos[vi],0.0,1.0);
  o.li = li;
  return o;
}
</script>


<script id="lightFS_PBR" type="text/wgsl">
@binding(0) @group(0) var gPos : texture_2d<f32>;
@binding(1) @group(0) var gNorm: texture_2d<f32>;
@binding(2) @group(0) var gAlb: texture_2d<f32>;
@binding(3) @group(0) var gMat: texture_2d<f32>;
@binding(4) @group(0) var<uniform> camPos : vec3<f32>;

struct lightData {
  pos : vec3<f32>,
  intensity : f32,  
  color : vec3<f32>,
  state : i32
};

@binding(0) @group(1) var<storage,read> lights: array<lightData>;

@fragment
fn main(@builtin(position) fragCoord: vec4<f32>, @location(0) @interpolate(flat) li: u32) -> @location(0) vec4<f32> {
  // размеры экрана
 
  
  // let amb      = vec3<f32>(0.025, 0, 0); 
  let ip = vec2u(fragCoord.xy);
  let t = textureLoad(gAlb,ip,0);

  let depth = t.w;

  // Don't light the sky.
 if (depth <= 0.0 || lights[li].state!=1) {
    return vec4(0);
 }

  // извлекаем данные из G-буфера
  let pos = textureLoad(gPos, ip, 0).xyz;          // world-space позиция
  let n   = normalize(textureLoad(gNorm, ip, 0).xyz); // world-space нормаль
  let albedo  = textureLoad(gAlb, ip, 0).rgb;          // albedo
  let mt = textureLoad(gMat, ip, 0);

  let metallic = clamp(mt.r, 0.0, 1.0);
  let roughness = clamp(mt.g, 0.04, 1.0);
  let light = lights[li];


  let v = normalize(camPos - pos);   // от фрагмента к камере
/*
  let l = normalize(light.pos - pos);     

*/
  let dist = length(light.pos - pos);
  let l = (light.pos - pos) / dist;
  let attenuation = 1.0 / (dist * dist);
  let lightColor = light.color * light.intensity * attenuation;

  let h = normalize(v + l);

 // ---- PBR формулы ----
    let NdotL = max(dot(n, l), 0.0);
    let NdotV = max(dot(n, v), 0.0);
    let NdotH = max(dot(n, h), 0.0);
    let VdotH = max(dot(v, h), 0.0);

    let F0 = mix(vec3<f32>(0.04), albedo, metallic);
    let F = F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - VdotH, 5.0);

    let a = roughness * roughness;
    let a2 = a * a;
    let Ddenom = (NdotH * NdotH) * (a2 - 1.0) + 1.0;
    let D = a2 / (3.14159265 * Ddenom * Ddenom);

    let r = roughness + 1.0;
    let k = (r * r) / 8.0;
    let Gv = NdotV / (NdotV * (1.0 - k) + k);
    let Gl = NdotL / (NdotL * (1.0 - k) + k);
    let G = Gv * Gl;

    let numerator = D * G * F;
    let denominator = 4.0 * NdotV * NdotL + 0.001;
    let specular = numerator / denominator;

    let kS = F;
    let kD = (vec3<f32>(1.0) - kS) * (1.0 - metallic);
    let diffuse = albedo / 3.14159265;

    let color = (kD * diffuse + specular) * lightColor * NdotL;
    /*color = vec3(1.0) - exp(-color*exposure);*/
  return vec4<f32>(color, 1.0);
}
</script>
<script id="genmipmaps" type="text/wgsl">
@group(0) @binding(0) var srcTex: texture_2d<f32>;
@group(0) @binding(1) var dstTex: texture_storage_2d<rgba32float, write>;

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let dstSize = textureDimensions(dstTex);
    if (gid.x >= dstSize.x || gid.y >= dstSize.y) { return; }

    // Координаты предыдущего уровня (2x2 пикселя)
    let srcCoord = vec2<u32>(gid.xy * 2u);
    //var color = vec4<f32>(0.0);

    // Усредняем 2x2
    //color += textureLoad(srcTex, srcCoord + vec2<u32>(0,0), 0);
   // color += textureLoad(srcTex, srcCoord + vec2<u32>(1,0), 0);
    //color += textureLoad(srcTex, srcCoord + vec2<u32>(0,1), 0);
    //color += textureLoad(srcTex, srcCoord + vec2<u32>(1,1), 0);
    //color = color * 0.25;
    var logColor = vec3<f32>(0.0);
    let epsilon = 1e-6;

    for (var oy = 0u; oy < 2u; oy++) {
        for (var ox = 0u; ox < 2u; ox++) {
            let c = textureLoad(srcTex, srcCoord + vec2<u32>(ox, oy), 0).rgb;
            logColor += log(max(c, vec3<f32>(epsilon)));
        }
    }

    logColor *= 0.25;
    let avg = exp(logColor);

    textureStore(dstTex, vec2<i32>(gid.xy), vec4<f32>(avg,1.0));
}
</script>
<script id="gen_material_mipmaps" type="text/wgsl">
@group(0) @binding(0) var srcTex: texture_2d<f32>;
@group(0) @binding(1) var dstTex: texture_storage_2d<rgba32float, write>;

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let dstSize = textureDimensions(dstTex);
    if (gid.x >= dstSize.x || gid.y >= dstSize.y) { return; }

    // Координаты предыдущего уровня (2x2 пикселя)
    let srcCoord = vec2<u32>(gid.xy * 2u);
    var sumRoughSq: f32 = 0.0;
    var metallicMax: f32 = 0.0;

    for (var oy = 0u; oy < 2u; oy++) {
        for (var ox = 0u; ox < 2u; ox++) {
            let texel = textureLoad(srcTex, srcCoord + vec2<u32>(ox, oy), 0);
            let rough = texel.r;
            let metal = texel.g; // допустим metallic хранится в g
            sumRoughSq += rough * rough;
            metallicMax = max(metallicMax, metal);
        }
    }

    let roughRMS = sqrt(sumRoughSq * 0.25);
    textureStore(dstTex, vec2<i32>(gid.xy), vec4<f32>(roughRMS, metallicMax, 0.0, 1.0));    
}
</script>
<script>
class MipMapGenerator {
    constructor(device,shaderCode) {
    this.device = device;

    this.pipeline = device.createComputePipeline({
      layout: 'auto',
      compute: {
        module: device.createShaderModule({ code: shaderCode }),
        entryPoint: 'main',
      },
    });


  }

  async generateMipmaps(texture, mipLevelCount,) {
  

    for (let level = 1; level < mipLevelCount; level++) {
            const width = Math.max(1, texture.width >> level);
            const height = Math.max(1, texture.height >> level);

            const bindGroup = this.device.createBindGroup({
            layout: this.pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: texture.createView({ baseMipLevel: level-1, mipLevelCount: 1 }) },
                { binding: 1, resource: texture.createView({ baseMipLevel: level, mipLevelCount: 1 }) }
            ]
            });

            const commandEncoder = this.device.createCommandEncoder();
            const pass = commandEncoder.beginComputePass();
            pass.setPipeline(this.pipeline);
            pass.setBindGroup(0, bindGroup);

            const workgroupX = Math.ceil(width / 8);
            const workgroupY = Math.ceil(height / 8);
            pass.dispatchWorkgroups(workgroupX, workgroupY);
            pass.end();

            this.device.queue.submit([commandEncoder.finish()]);
        }
    }
}

class LightBuffer {
  constructor(device, maxLights = 1024) {
    this.device = device;
    this.maxLights = maxLights;

    const lightSize = 32;
    this.bufferSize = maxLights * lightSize;
    this.data = new ArrayBuffer(this.bufferSize);
    this.view = new DataView(this.data);
    this.buffer = device.createBuffer({
      size: this.bufferSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    this.count = 0;
    this.dirty = false;
  }

  addLight(position, color, intensity = 1.0, active = 1) {
    if (this.count >= this.maxLights) return;
    const offset = this.count * 32;
    const f = new Float32Array(this.data, offset, 7);
    f.set([position[0], position[1], position[2], intensity,
           color[0], color[1], color[2]]);
    this.view.setInt32(offset + 28, active, true);

    this.count++;

    this.dirty = true;
  }

  updateLight(index, { position, color, intensity, active }) {
    if (index < 0 || index >= this.count) return;
    const offset = index * 32;
    const f = new Float32Array(this.data, offset, 7);
    if (position) f.set(position, 0);
    if (intensity !== undefined) f[3] = intensity;
    if (color) f.set(color, 4);
    if (active !== undefined) this.view.setInt32(offset + 28, active, true);
    this.dirty = true;
  }

  updateGPU() {
    if (!this.dirty) return;
    this.device.queue.writeBuffer(this.buffer, 0, this.data);
    this.dirty = false;
  }
}
  
</script>
<script type="module">


(async function() {

  

  const canvas = document.getElementById('gpuCanvas');
  if (!navigator.gpu) { alert('WebGPU не поддерживается в этом браузере'); return; }
 
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) { alert('Не удалось получить GPU adapter'); return; }
  console.log(adapter.limits);

  const device = await adapter.requestDevice({requiredLimits: {
    maxColorAttachmentBytesPerSample: adapter.limits.maxColorAttachmentBytesPerSample,
  },requiredFeatures: ['float32-filterable']});

  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
  const context = canvas.getContext('webgpu');

  // set canvas size & configure context (no 'size' field)
  function fitToWindow() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(window.innerWidth * dpr));
    canvas.height = Math.max(1, Math.floor(window.innerHeight * dpr));
    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'opaque'
    });
  }

  function identity() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }

  

  function translate(out, v) {
    out = out || identity();
    const x=v[0], y=v[1], z=v[2];
    out[12] = out[0]*x + out[4]*y + out[8]*z + out[12];
    out[13] = out[1]*x + out[5]*y + out[9]*z + out[13];
    out[14] = out[2]*x + out[6]*y + out[10]*z + out[14];
    out[15] = out[3]*x + out[7]*y + out[11]*z + out[15];
    return out;
  }
  let lightBG;

  window.addEventListener('resize', () => { fitToWindow(); recreateGbuffers(); updateProjection();lightBG = createLightBindGroup(); });

  fitToWindow();


const cameraBuffer = device.createBuffer({
  size: 48 * Float32Array.BYTES_PER_ELEMENT,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

  // Simple cube (24 verts)
  function createCube(edge=5) {
    const h = edge*0.5;
    const positions = [
      -h,-h, h,  h,-h, h,  h,h, h,  -h,h, h,
      -h,-h,-h, -h,h,-h,  h,h,-h,  h,-h,-h,
      -h,-h,-h, -h,-h, h,  -h,h, h,  -h,h,-h,
      h,-h,-h,  h,h,-h,  h,h, h,  h,-h, h,
      -h,h,-h,  -h,h, h,  h,h, h,  h,h,-h,
      -h,-h,-h,  h,-h,-h,  h,-h, h,  -h,-h, h
    ];
    const normals = [
      0,0,1, 0,0,1, 0,0,1, 0,0,1,
      0,0,-1,0,0,-1,0,0,-1,0,0,-1,
      -1,0,0,-1,0,0,-1,0,0,-1,0,0,
      1,0,0,1,0,0,1,0,0,1,0,0,
      0,1,0,0,1,0,0,1,0,0,1,0,
      0,-1,0,0,-1,0,0,-1,0,0,-1,0
    ];
  /*  const uvs = new Array(24*2).fill(0).map((_,i)=> (i%2===0?((i/2)%2):Math.floor((i/2)%2)) );*/
    // simple checker uvs above are dummy; we'll set correct uvs:
    const uvList = [
      0,0,1,0,1,1,0,1,
      1,0,0,0,0,1,1,1,
      0,0,0,1,1,1,1,0,
      1,0,1,1,0,1,0,0,
      0,1,1,1,1,0,0,0,
      0,0,1,0,1,1,0,1
    ];
    const indices = new Uint16Array([
      0,1,2, 2,3,0,
      4,5,6, 6,7,4,
      8,9,10, 10,11,8,
      12,13,14, 14,15,12,
      16,17,18, 18,19,16,
      20,21,22, 22,23,20
    ]);
    const verts = new Float32Array(24 * (3+3+2));
    for (let i=0;i<24;i++){
      verts[i*8+0]=positions[i*3+0];
      verts[i*8+1]=positions[i*3+1];
      verts[i*8+2]=positions[i*3+2];
      verts[i*8+3]=normals[i*3+0];
      verts[i*8+4]=normals[i*3+1];
      verts[i*8+5]=normals[i*3+2];
      verts[i*8+6]=uvList[i*2+0];
      verts[i*8+7]=uvList[i*2+1];
    }
    return {vertexData: verts, indices};
  }

  const cube = createCube(4);
  const vertexBuffer = device.createBuffer({size: cube.vertexData.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST});
  device.queue.writeBuffer(vertexBuffer, 0, cube.vertexData.buffer, cube.vertexData.byteOffset, cube.vertexData.byteLength);
  const indexBuffer = device.createBuffer({size: cube.indices.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST});
  device.queue.writeBuffer(indexBuffer, 0, cube.indices.buffer, cube.indices.byteOffset, cube.indices.byteLength);

  // create a small checker texture (4x4) — use rgba8unorm and padded bytesPerRow (multiple of 256)
 


async function createCheckerAlbedo(device,mipgen, cellsX, cellsY, cellSize, color1 = [0,0,0,1], color2 = [1,1,1,1]) {
  const texW = cellsX * cellSize;
  const texH = cellsY * cellSize;

  const bytesPerPixel = 16; // RGBA32F
  const arrElementsPerPixel = 4;
  /*
  const bytesPerRow = Math.ceil(texW * bytesPerPixel / 256) * 256;
  const floatsPerRow = bytesPerRow / 4;*/
  const mipLevelCount = Math.floor(Math.log2(Math.max(texW, texH))) + 1;

  const texData = new Float32Array(texW * texH * arrElementsPerPixel);

  for (let y = 0; y < texH; y++) {
    for (let x = 0; x < texW; x++) {

      // Определяем цвет клетки
      const cellX = Math.floor(x / cellSize);
      const cellY = Math.floor(y / cellSize);
      const isEven = (cellX + cellY) % 2 === 0;
      const color = isEven ? color1 : color2;
      const index = y*texW*arrElementsPerPixel+x*arrElementsPerPixel;
      texData.set([color[0],color[1],color[2],color[3]],index);
  }
}

  const albedoTex = device.createTexture({
    size: [texW, texH, 1],
    format: 'rgba32float',
    mipLevelCount:mipLevelCount,
    usage: GPUTextureUsage.TEXTURE_BINDING |
           GPUTextureUsage.COPY_DST |
           GPUTextureUsage.RENDER_ATTACHMENT | 
           GPUTextureUsage.STORAGE_BINDING
  });
  
  device.queue.writeTexture(
    { texture: albedoTex },
    texData,
    { bytesPerRow:texW * bytesPerPixel},
    { width: texW, height: texH, depthOrArrayLayers: 1 }
  );

  await mipgen.generateMipmaps(albedoTex,mipLevelCount);

  return albedoTex.createView();
}

const mipsAlbedo = new MipMapGenerator(device,document.querySelector("#genmipmaps").textContent);
const mipsMaterial = new MipMapGenerator(device,document.querySelector("#gen_material_mipmaps").textContent);

const checkerView = await createCheckerAlbedo(device,mipsAlbedo,3,3,256,[0,0,0,1],[0,1,0,1]);

async function createMRTexture(device, mipgen, texW, texH, options = {}) {
  const {
    pattern = 'gradient',       // 'gradient' или 'checker'
    metallicRange = [0, 1],     // [min, max] для metallic
    roughnessRange = [0, 1],
    cellSize = 16,     // [min, max] для roughness
  } = options;
  
  const bytesPerPixel = 16; // RGBA32F
  const bytesPerRow = texW * bytesPerPixel;
  const floatsPerRow = bytesPerRow / 4;
  const mipLevelCount = Math.floor(Math.log2(Math.max(texW, texH))) + 1;
  const padded = new Float32Array(floatsPerRow * texH);

  for (let y = 0; y < texH; y++) {
    for (let x = 0; x < texW; x++) {
      const dst = y * floatsPerRow + x * 4;

      let metallic, roughness;

      if (pattern === 'gradient') {
        metallic = metallicRange[0] + (metallicRange[1] - metallicRange[0]) * (y / (texH - 1));
        roughness = roughnessRange[0] + (roughnessRange[1] - roughnessRange[0]) * (x / (texW - 1));
      } else if (pattern === 'checker') {
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        metallic = ( (cellX + cellY) % 2) ? metallicRange[1] : metallicRange[0];
        roughness = ( (cellX + cellY) % 2) ? roughnessRange[1] : roughnessRange[0];
      } else {
        metallic = metallicRange[0];
        roughness = roughnessRange[0];
      }

      padded[dst + 0] = metallic;
      padded[dst + 1] = roughness;
      padded[dst + 2] = 0.0;
      padded[dst + 3] = 1.0;
    }
  }

  const mrTex = device.createTexture({
    size: [texW, texH, 1],
    format: 'rgba32float',
    mipLevelCount:mipLevelCount,
    usage: GPUTextureUsage.TEXTURE_BINDING |
           GPUTextureUsage.COPY_DST |
           GPUTextureUsage.RENDER_ATTACHMENT | 
           GPUTextureUsage.STORAGE_BINDING
  });

  device.queue.writeTexture(
    { texture: mrTex },
    padded,
    { bytesPerRow, rowsPerImage: texH },
    { width: texW, height: texH, depthOrArrayLayers: 1 }
  );

  await mipgen.generateMipmaps(mrTex ,mipLevelCount);
  return mrTex.createView();
}

const gradientMR = await createMRTexture(device,mipsMaterial, 512, 512, { 
  pattern: 'gradient', 
  metallicRange: [0,0], 
  roughnessRange: [1, 1] 
});

// 2. Шахматка
const checkerMR = await createMRTexture(device,mipsMaterial, 512, 512, { 
  pattern: 'checker', 
  metallicRange: [0, 0], 
  roughnessRange: [1, .5],
  cellSize:128,
});

  // G-buffers placeholders
  
  let gPositionTex, gNormalTex, gAlbedoTex, gMaterialTex, depthTex, gPosView, gNormView, gAlbedoView, gMaterialView, depthView;

  function recreateGbuffers() {
    const w = canvas.width;
    const h = canvas.height;
    if (gPositionTex) { try { gPositionTex.destroy(); gNormalTex.destroy(); gAlbedoTex.destroy(); depthTex.destroy(); } catch(e){} }
    gPositionTex = device.createTexture({size:[w,h,1], format:'rgba32float', usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING});
    gNormalTex   = device.createTexture({size:[w,h,1], format:'rgba32float', usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING});
    gAlbedoTex   = device.createTexture({size:[w,h,1], format:'rgba32float', usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING});
    gMaterialTex   = device.createTexture({size:[w,h,1], format:'rgba32float', usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING});
    depthTex     = device.createTexture({size:[w,h,1], format:'depth32float', usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING});
    gPosView = gPositionTex.createView();
    gNormView = gNormalTex.createView();
    gAlbedoView = gAlbedoTex.createView();
    gMaterialView = gMaterialTex.createView();
    depthView = depthTex.createView();
  }
  recreateGbuffers();


  const geomVSFS = `struct ObjectData {
    model : mat4x4<f32>,
    color : vec4<f32>
};

struct U{
    view : mat4x4<f32>,
    proj : mat4x4<f32>,
};
@group(0) @binding(0)
var<storage, read> objects : array<ObjectData>;

@group(1) @binding(0) var texAlbedo : texture_2d<f32>;
@group(1) @binding(1) var texSampler : sampler;

@group(2) @binding(0)
var<uniform> camera : U;

struct VSOut {
    @builtin(position) pos : vec4<f32>,
    @location(0) worldPos : vec3<f32>,
    @location(1) normal : vec3<f32>,
    @location(2) uv : vec2<f32>,
    @location(3) color : vec4<f32>,
};

@vertex
fn vs_main(@location(0) position: vec3<f32>,
           @location(1) normal: vec3<f32>,
           @location(2) uv: vec2<f32>,
           @builtin(instance_index) i: u32) -> VSOut {
    let obj = objects[i];
    var out: VSOut;
    let world = obj.model * vec4<f32>(position, 1.0);
    out.pos = camera.proj * camera.view * world;
    out.worldPos = world.xyz;
    out.normal = normalize((obj.model * vec4<f32>(normal,0.0)).xyz);
    out.uv = uv;
    out.color = obj.color;
    return out;
};

struct FSout {
  @location(0) gPosition : vec4<f32>,
  @location(1) gNormal : vec4<f32>,
  @location(2) gAlbedo : vec4<f32>
};

@fragment
fn fs_main(in: VSOut) -> FSout {
  var o: FSout;
  o.gPosition = vec4<f32>(in.worldPos, 1.0);     // world space
  o.gNormal = vec4<f32>(normalize(in.normal), 1.0); // world space normal
  o.gAlbedo = vec4<f32>(textureSample(texAlbedo, texSampler, in.uv).rgb * in.color.rgb, 1.0);
  return o;
}`;
  
  const geomVS = document.querySelector("#geomVS_PBR").textContent;
  const geomFS = document.querySelector("#geomFS_PBR").textContent;
  const lightVS = document.querySelector("#lightVS").textContent;
  const lightFS = document.querySelector("#lightFS_PBR").textContent;

  // Pipelines
  const geomPipeline = device.createRenderPipeline({
    label:'geom',
    layout: 'auto',
    vertex: {
      module: device.createShaderModule({code: geomVS}),
      entryPoint: 'main',
      buffers: [{ arrayStride: 8*4, attributes: [
        {shaderLocation:0, offset:0, format:'float32x3'},
        {shaderLocation:1, offset:12, format:'float32x3'},
        {shaderLocation:2, offset:24, format:'float32x2'}
      ]}]
    },
    fragment: {
      module: device.createShaderModule({code: geomFS}),
      entryPoint: 'main',
      targets: [
        {format: 'rgba32float'},
        {format: 'rgba32float'},
        {format: 'rgba32float'},
        {format: 'rgba32float'}     ]
    },
    primitive: {topology:'triangle-list', cullMode:'back'},
    depthStencil: {format:'depth32float', depthWriteEnabled:true, depthCompare:'greater-equal'}
  });
/*
const geomModule = device.createShaderModule({code: geomVSFS});

const newGeomPipeLine = device.createRenderPipeline({
  layout:'auto',
  vertex: {
      module: geomModule,
      entryPoint: 'vs_main',
      buffers: [{ arrayStride: 8*4, attributes: [
        {shaderLocation:0, offset:0, format:'float32x3'},
        {shaderLocation:1, offset:12, format:'float32x3'},
        {shaderLocation:2, offset:24, format:'float32x2'}
      ]}]
    },
    fragment: {
      module: geomModule,
      entryPoint: 'fs_main',
      targets: [
        {format: 'rgba32float'},
        {format: 'rgba32float'},
        {format: 'rgba32float'},
      ]
    },
    primitive: {topology:'triangle-list', cullMode:'back'},
    depthStencil: {format:'depth32float', depthWriteEnabled:true, depthCompare:'less'}
  });
*/
  const lightPipeline = device.createRenderPipeline({
    label:'light',
    layout: 'auto',
    vertex: { module: device.createShaderModule({code: lightVS}), entryPoint:'main' },
    fragment: { 
      module: device.createShaderModule({code: lightFS}), 
      entryPoint:'main',
      targets:[{
        format: presentationFormat,
        blend: {
          color: {
            srcFactor: 'one',
            dstFactor: 'one',
            operation: 'add',
          },
          alpha: {
            srcFactor: 'one',
            dstFactor: 'one',
            operation: 'add',
          }
        }
      }] 
    },
    primitive: {topology:'triangle-list'},
  });

  const sampler = device.createSampler({ magFilter:'linear', minFilter:'linear', mipmapFilter: "linear", maxAnisotropy:8 });
  const modelMtBuffer = device.createBuffer({size: 16 * Float32Array.BYTES_PER_ELEMENT, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST});

  const gBindGroups = [];

  gBindGroups.push(device.createBindGroup({
    layout: geomPipeline.getBindGroupLayout(0),
    entries: [
      {binding:0, resource: { buffer: cameraBuffer }},
      {binding:1, resource:{ buffer: modelMtBuffer }}
    ]
  }));
  gBindGroups.push(device.createBindGroup({
    layout: geomPipeline.getBindGroupLayout(1),
    entries: [
      {binding:0, resource: sampler},
      {binding:1, resource: checkerView},
      {binding:2, resource: checkerMR}
    ]
  }));
  // small cam pos buffer for lighting shader
  const camPosBuffer = device.createBuffer({size: 3 * Float32Array.BYTES_PER_ELEMENT, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST});
  
  function createLightBindGroup() {
    return device.createBindGroup({
      layout: lightPipeline.getBindGroupLayout(0),
      entries: [
        {binding:0, resource: gPosView},
        {binding:1, resource: gNormView},
        {binding:2, resource: gAlbedoView},
        {binding:3, resource: gMaterialView},
        {binding:4, resource: { buffer: camPosBuffer }}
      ]
    });
  }

  // camera math (quat->view)
  function quatToViewMatrix(q, pos) {
    const x=q[0], y=q[1], z=q[2], w=q[3];
    const xx=x*x, yy=y*y, zz=z*z, xy=x*y, xz=x*z, yz=y*z, wx=w*x, wy=w*y, wz=w*z;
    const m = new Float32Array([
      1 - 2*(yy+zz), 2*(xy + wz),   2*(xz - wy), 0,
      2*(xy - wz),   1 - 2*(xx+zz), 2*(yz + wx), 0,
      2*(xz + wy),   2*(yz - wx),   1 - 2*(xx+yy), 0,
      0,0,0,1
    ]);
    m[12] = -(m[0]*pos[0] + m[4]*pos[1] + m[8]*pos[2]);
    m[13] = -(m[1]*pos[0] + m[5]*pos[1] + m[9]*pos[2]);
    m[14] = -(m[2]*pos[0] + m[6]*pos[1] + m[10]*pos[2]);
    return m;
  }
  function perspective(fov, aspect, near, far) {
    const f = 1.0 / Math.tan(fov/2);
    const out = new Float32Array(16);
    out[0] = f / aspect;
    out[5] = f;
    out[10] = (far ) / (near - far);
    out[11] = -1;
    out[14] = (far * near) / (near - far);
    out[15] = 0;
    return out;
  }

  let projMatrix;
  const camArr = new Float32Array(48);
  function updateProjection()
  { projMatrix = perspective(Math.PI/5, canvas.width / canvas.height, 0.1, 300.0);
    camArr.set(projMatrix,16); 
  }

  // Camera state
  let camPos = new Float32Array([0,0,20]);
  let camQuat = [0,0,0,1];
  let camMoveSpeed = 0.5;
  let rotateSpeed = 0.0666;
  let keys = {};
  let pointerLocked = false;
  canvas.addEventListener('click', ()=> canvas.requestPointerLock());
  document.addEventListener('pointerlockchange', ()=> pointerLocked = (document.pointerLockElement === canvas));
  document.addEventListener('mousemove', (e)=> {
    if (!pointerLocked) return;
    const dt = Math.max(1/60, (lastTime?deltaTime/1000:1/60));
    const pitch = e.movementY * rotateSpeed * dt * Math.PI * 2;
    const yaw   = e.movementX * rotateSpeed * dt * Math.PI * 2;
    if (e.ctrlKey) applyDeltaQuat([0,0,yaw]); else applyDeltaQuat([pitch,yaw,0]);
  });
  document.addEventListener('keydown', e=> keys[e.code]=true);
  document.addEventListener('keyup', e=> keys[e.code]=false);

  function normalize(q) { const l=Math.hypot(...q)||1; return q.map(x=>x/l); }
  function multiplyQuat(a,b) {
    const [ax,ay,az,aw]=a, [bx,by,bz,bw]=b;
    return [
      aw*bx + ax*bw + ay*bz - az*by,
      aw*by - ax*bz + ay*bw + az*bx,
      aw*bz + ax*by - ay*bx + az*bw,
      aw*bw - ax*bx - ay*by - az*bz
    ];
  }
  function axisAngleToQuat(ax,ay,az,angle){
    const h = angle*0.5, s=Math.sin(h), c=Math.cos(h); const len=Math.hypot(ax,ay,az)||1;
    return [ax/len*s, ay/len*s, az/len*s, c];
  }
  function applyDeltaQuat([pitch,yaw,roll]) {
    const qx = axisAngleToQuat(1,0,0,pitch);
    const qy = axisAngleToQuat(0,1,0,yaw);
    const qz = axisAngleToQuat(0,0,1,roll);
    let dq = multiplyQuat(qy, qx); dq = multiplyQuat(dq, qz);
    camQuat = normalize(multiplyQuat(dq, camQuat));
    camArr.set(quatToViewMatrix(camQuat, camPos),0);
  }

  // movement local
  function moveCameraLocal(dx,dy,dz) {
    const view = quatToViewMatrix(camQuat,[0,0,0]);
    const moveX = dx*view[0] + dy*view[1] + dz*view[2];
    const moveY = dx*view[4] + dy*view[5] + dz*view[6];
    const moveZ = dx*view[8] + dy*view[9] + dz*view[10];
    camPos[0]+=moveX; camPos[1]+=moveY; camPos[2]+=moveZ;
  }

  // Time & loop
  let lastTime = performance.now(), deltaTime = 16;
  const modelMatrix = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 3, 1
]);

lightBG = createLightBindGroup();
updateProjection();

const lightDataBuffer = new LightBuffer(device);

lightDataBuffer.addLight([0,1,-3],[1,0,0],100);
lightDataBuffer.addLight([1,2,3],[0,1,0],100);
lightDataBuffer.addLight([3,3,3],[0,0,1],100);
lightDataBuffer.addLight([0,6,1],[.8,.9,.7],100);
lightDataBuffer.addLight([0,-6,0],[1,1,1],50);
lightDataBuffer.addLight([20,50,-5],[1,0,0],100);
lightDataBuffer.addLight([0,-50,2],[1,0,1],100);

const lightDataBG = device.createBindGroup({
      label:"LightBG",
      layout: lightPipeline.getBindGroupLayout(1),
      entries: [
        {binding:0, resource: { buffer: lightDataBuffer.buffer}},
      ]
    });
    
let viewM = quatToViewMatrix(camQuat, camPos);
camArr.set(viewM,0);
device.queue.writeBuffer(camPosBuffer, 0, camPos);
const info = document.querySelector("#info");
const fpsCounter = document.querySelector("#fps");

function frame(now) {
    deltaTime = now - lastTime; lastTime = now;
    const moveDt = deltaTime * camMoveSpeed * 0.06;
    let dx=0,dy=0,dz=0;
    if (keys['KeyW']) dz -= 1;
    if (keys['KeyS']) dz += 1;
    if (keys['KeyA']) dx -= 1;
    if (keys['KeyD']) dx += 1;
    if (keys['ShiftLeft']) dy += 1;
    if (keys['KeyZ']) dy -= 1;
    if (dx||dy||dz) {
      let s = Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
      if (s==2) s=Math.SQRT2; if (s==3) s=Math.sqrt(3); if (!s) s=1;
      dx *= (moveDt * s); dy *= (moveDt * s); dz *= (moveDt * s);
      moveCameraLocal(dx,dy,dz);
      viewM = quatToViewMatrix(camQuat, camPos);
      camArr.set(viewM,0);
      device.queue.writeBuffer(camPosBuffer, 0, camPos);
    }


    info.innerHTML=`x: ${camPos[0].toFixed(2)} y: ${camPos[1].toFixed(2)} z: ${camPos[2].toFixed(2)}`;
    fpsCounter.value=(1000/deltaTime).toFixed(0);
    device.queue.writeBuffer(cameraBuffer, 0, camArr.buffer, camArr.byteOffset, camArr.byteLength);
    device.queue.writeBuffer(modelMtBuffer, 0, modelMatrix.buffer, modelMatrix.byteOffset, modelMatrix.byteLength);

    var x = Math.sign(Math.sin(now*.002)) * Math.pow(Math.abs(Math.sin(now*.002)), .3);
    var y = Math.sign(Math.cos(now*.002)) * Math.pow(Math.abs(Math.cos(now*.002)), .3);
    var l = Math.hypot(x, y);
    x /=l;
    y /=l;

    lightDataBuffer.updateLight(4,{position:[6*x,0,6*y]});
    lightDataBuffer.updateLight(1,{position:[1,3+3*Math.cos(now*.0005),5+2*Math.sin(now*.001)]});
    lightDataBuffer.updateLight(6,{position:[0,-50+42*Math.sin(now*0.001),2]});
    var r = Math.abs(Math.sin(now*0.001));
    var b = Math.abs(Math.sin(now*0.004*.333));
    var g = 0;

    lightDataBuffer.updateLight(6,{color:[r,g,b]});
    lightDataBuffer.updateGPU();

    // render
    const encoder = device.createCommandEncoder();
    // geometry pass -> to G-buffers
    const geomPass = encoder.beginRenderPass({
      colorAttachments: [
        { view: gPosView, loadOp:'clear', clearValue:{r:0,g:0,b:0,a:0}, storeOp:'store' },
        { view: gNormView, loadOp:'clear', clearValue:{r:0,g:0,b:0,a:0}, storeOp:'store' },
        { view: gAlbedoView, loadOp:'clear', clearValue:{r:0,g:0,b:0,a:0}, storeOp:'store' },
        { view: gMaterialView, loadOp:'clear', clearValue:{r:0,g:0,b:0,a:0}, storeOp:'store' }
      ],
      depthStencilAttachment: { view: depthView, depthLoadOp:'clear', depthClearValue:0.0, depthStoreOp:'store' }
    });
    geomPass.setPipeline(geomPipeline);
    geomPass.setBindGroup(0, gBindGroups[0]);
    geomPass.setBindGroup(1, gBindGroups[1]);
    geomPass.setVertexBuffer(0, vertexBuffer);
    geomPass.setIndexBuffer(indexBuffer,'uint16');
    geomPass.drawIndexed(cube.indices.length,1,0,0,0);
    geomPass.end();

    // lighting pass -> fullscreen
    
    const lightPass = encoder.beginRenderPass({
      colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp:'clear', clearValue:{r:0,g:0,b:0,a:0}, storeOp:'store' }]
    });
    lightPass.setPipeline(lightPipeline);
    lightPass.setBindGroup(0, lightBG);
    lightPass.setBindGroup(1, lightDataBG);
    lightPass.draw(3,lightDataBuffer.count,0,0);
    lightPass.end();

    device.queue.submit([encoder.finish()]);
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
